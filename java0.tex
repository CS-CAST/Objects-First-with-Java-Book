%\documentclass{book}
\documentclass{article}

%https://www.overleaf.com/learn/latex/Creating_a_document_in_LaTeX

%https://www.overleaf.com/learn/latex/Code_Highlighting_with_minted

%https://www.overleaf.com/learn/latex/TikZ_package
%https://tex.stackexchange.com/questions/223694/how-to-draw-a-text-box-with-shadow-borders-i-have-tried-the-following-but-it-gi

%pretty stuff
\usepackage{blindtext}
\usepackage[skins]{tcolorbox}
\usepackage{xcolor}
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}

%https://tex.stackexchange.com/questions/341924/automatically-set-different-colors-for-matching-brackets
\makeatletter
\newcount\bracketnum
\newcommand\makecolorlist[1]{%
    \bracketnum0\relax
    \makecolorlist@#1,.%
    \bracketnum0\relax
}
\def\makecolorlist@#1,{%
    \advance\bracketnum1\relax
    \expandafter\def\csname bracketcolor\the\bracketnum\endcsname{\color{#1}}%
    \@ifnextchar.{\@gobble}{\makecolorlist@}%
}
\let\oldleft\left
\let\oldright\right
\def\left#1{%
    \global\advance\bracketnum1\relax 
    \colorlet{temp}{.}%
    \csname bracketcolor\the\bracketnum\endcsname
    \oldleft#1%
    \color{temp}%
}
\def\right#1{%
    \colorlet{temp}{.}%
    \csname bracketcolor\the\bracketnum\endcsname
    \oldright#1%
    \global\advance\bracketnum-1\relax
    \color{temp}%
}
\makeatother


\makecolorlist{red,blue,orange, purple,green}





\usepackage{hyperref}


%code stuff
\usepackage{minted}
\usepackage{verbatim}

\usemintedstyle{pastie}

%\maketitle
\title{A Guided Introduction to Thinking \emph{with} and \emph{about} Object Oriented Programming}

\author{Don Davis, PhD}
\date{\today}

\setlength{\parindent}{5ex}
\begin{document}

\begin{comment}

  1. Explain why object oriented programming
  2. Rabbit example
  3. Work backwards from Pokemon-like linked list example
  

\end{comment}

\begin{center}

  \textbf{
 {\LARGE A Guided Introduction to \\
  Thinking \emph{With} and \emph{About} \\ 
  Object Oriented Programming \\}
 }
\end{center}

\begin{flushleft}
%\chapter{Introduction}
  \section{Introduction to Abstraction}
  \setlength{\parindent}{5ex}
  The purpose of learning computer science, especially at the high school level, is not to memorize syntax. Rather, we are working to develop approaches to solving problems. Some of the best tools that we have to solve problems are programming languages.\par
  Almost all programming languages help solve problems. Some languages are better suited to specific problems than other languages. There are many elements of a programming language that help solve problems. These elements can include built-in commands, data types, as well as the structure of the language itself.\par
  When beginning a programming language, it is common to struggle over syntactical features such as commas, semi-colons, or indentation. Although, those elements must be correct for programs to work - they are \textit{minor details} that simply support the true purpose of a programming language - \textbf{solving problems}. The structure of the programming language itself determines how we solve problems - namely, how we \textit{de-construct} and think about problems. \par
  When discussing programming languages, it is common to refer to \textit{low level} and \textit{high level} languages. By level, we are not refering to complexity but rather to the level of \textit{\textbf{abstraction}}. Whereby \textit{\textbf{abstraction}} refers to a general class - a broader collection of characteristcics or qualities. For example, when discussing the color \textit{red}, red does not refer to one specific color of one specific object, but rather refers to a color characteristic shared across objects that English speakers refer to as red. \par
  With programming languages, \textit{abstraction} can be seen in the amount of specificity commonly required and utilized across a program. For example, does each instance of \textit{red} require a specific hex combination for each pixel on a screen to be manually specified or can the programmer more generally, simply refer to \textit{red}?\\
 % \noindent
  A \textit{low level} programming language such as \textbf{C} might require the programmer to be very specific and provide low level specifics such as actual memory bits of the computer. By contrast, a \textit{high level} programming language such as \textbf{Processing}, \textbf{Python}, or \textbf{Java} may very well hide such details from the programmer - allowing the programmer to focus on more \textit{abstract} i.e. 'big picture' ideas. \par
  \section{Object Oriented Programming}
  \emph{What is Object Oriented Programming} (OOP)? Quite simply stated, OOP is programming structured around \emph{objects} - conglomerations of qualities and characteristics - rather than always detailing specific interactions with the computer's memory. This \emph{object oriented} approach is intended to simplify work for the programmer and improve programming efficiency by closer approximating real world complexity and interactions.\par
  \subsection{Generalization}
  A programmer can work to defining interactions across entire \emph{classes} of objects rather than having to specify interactions for each specific instance. \textbf{\emph{But what does that mean????}}\par
  \emph{\textbf{Imagine}} - if every time someone bought a new pair of shoes they had to learn a specific system for tying the laces on that particular pair of shoes. That would be highly inefficient. Rather, we as a society have developed a few methods of tying shoes. Learning to tie one type of shoe readily transfers to tying other types of shoe laces. The laborious process of learning to tie a specific type of shoe lace does not have to be repeated each time. Similarly, imagine that a shoemaker would not want to invent and create a new system for tying shoes each time they made a pair of shoes. Rather, a system would be created for tying shoes and that system could be \emph{inherited} by each pair of shoes that that shoemaker or other shoemakers could use. \par
  \subsection{Classes}
  \emph{\textbf{Imagine further}} - someone has developed a good underlying design (or \emph{template}) for shoes. In OOP, this can be refered to as a \emph{\textbf{class}}. In essence, a \emph{class} is like a recipe that can be used as the basic for making many similar, but differentiated, \emph{objects}. The shoemaker could create a \emph{class} (template, recipe, etc.) for a generic shoe design. That class could then be used to mass produce however many shoes of that type (with whatever specified variations) that the shoemaker wants. In terms of OOP, the shoe template would be the \emph{class} used to create individual shoe \emph{objects}, whereby each pair of shoes would be considered an \emph{instance} of \textbf{Class} Shoe.\par
  As programmers, and problem solvers (e.g. think about Algebra), the goal is not to spend all our time focused on very specific problems. Rather, we attempt to represent and solve as many problems as possible at once. Sometimes, it may indeed be necessary to specify the behaviors for very particular interactions in very particular contexts. Cf., we may use particular greetings in particular situations (e.g. a specific handshake for a specific friend)- but before we develop specific greetings we develop a generalized greeting such as \emph{Hi!} that can be broadly applicable.\par
  \textbf{\emph{But what does that mean????}} In short, as programmers and people, it is not time efficient to develop specific greetings for each individual person and take that approach to developing greetings for each possible random encounter. Someone could spend the better part of a month just planning out what they might say during a quick trip to the grocery store. Much more time effective is to plan a \emph{generalized} i.e. \emph{absracted} approach and simply plan on saying ``hello'' to everyone and plan exceptions from there. For example, plan on saying ``hello'' to everyone except for people whose name is known - then say ``hello \mintinline{c}{$personsname}.'' This \emph{abstracted} approach is the essence of OOP.\par
  In Java, or other similarly \emph{object oriented} programming languages, a class might simply be defined by something such as:
 \begin{minted}{Java}
  Class Person{ }
\end{minted}
However, such a code by itself is useless - because this \mintinline{Java}{Class Person} does not actually attribute any qualities to a person nor does it provide a way to create more Person objects i.e. people. 

\subsection{Data types}
  
One of the biggest, most important concepts in programming, and perhaps in the modern world, is that there are different types of data. We use different types pf data to answer different types of questions. For example, if someone asks ``What type of cookies are those?'' - the response ``12'' is not helpful or useful. Similarly, if someone asks ``How many cookies do you have?'' and is answered with ``chocolate chip'' - the response is neither helpful nor useful. A specific question requires a specific type of response.\par
In order to solve any problem, it is first important to understand what the problem is, the characteristics of the problem, and the likely characteristics of the solution. For example, if we are deciding on the types of cookies for a class party - some of the information we might need are numbers and type of cookies.\emph{Number} and \emph{Type} would be the data types we would use to discuss cookies. More cookie specific data types might include \emph{sugar-type} or \emph{leavening-agent}. As can be seen with the cookie example - certain data types make more sense based on the environment. In a cookie specific environment \emph{sugar-type} and \emph{leavening-agent} are very useful. However, in the design of cars they would basically be useless.\par
Data types in programming are those types of data that have been found to be most useful in programming i.e. computer related tasks. Therefore, each programming language has its own built in set of a data types. There is significant overlap - because there is significant overlap in the function of purpose of computer languages - also there is significant overlap because all computer languages must be designed to work on computers i.e. the actual specifics and architecture of processors determines the shape that a programming language takes - e.g. certain data types reflect the amount of space available in the computer's working memory. \par
\subsubsection{Data Types in Java}
In Java, the built-in i.e. hard-coded data types are referred to as \emph{primitives}. The \emph{primitive} data types in Java include:

\begin{tcolorbox}[enhanced,width=5in,center upper,
    fontupper=\bfseries,drop fuzzy shadow southwest,
    boxrule=0.4pt,sharp corners,colframe=yellow!80!black,colback=yellow!10]
\begin{itemize}
\item Whole numbers
  \begin{itemize}
  \item byte - a \textbf{whole number} (\emph{integer}) between -128 and 127 (8 bits)
  \item short - an \emph{integer} between -32768 and 32767 (16 bits)
  \item int  - an \emph{integer} between -2,147,483,648 and 2,147,483,647 (32 bits)
  \item long -  an \emph{integer} between 9,223,372,036,854,775,808 and
    9,223,372,036,854,755,807 (64 bits)
  \end{itemize}
  %\begin{itemize}
  \item Floating points (\textbf{decimal numbers})
    \begin{itemize}
    \item float - a decimal (\emph{floating point}) (32 bits)
    \item double - a decimal (\emph{floating point}) (64 bits)
    \end{itemize}
  %  \begin{itemize}
    \item Non numerical
      \begin{itemize}
      \item char - a Unicode character e.g. one single letter, one single number, one single type of punctuation, etc. 
        \item boolean - true or false 
      \end{itemize}
\end{itemize}
\end{tcolorbox}


{\footnotesize See also the \href{https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html}{official Java documentation}.} 
\subsubsection{Strings}
Another very common data type, that is \textbf{not} a \emph{primitive} is the  \mintinline{Java}{String}. A  \mintinline{Java}{String} is simply an \emph{array} (i.e. list) of characters. For example,  \mintinline{Java}{String name=''John Doe''} contains all the characters and spaces for J-o-h-n-space-D-o-e. Because \emph{Strings} are \emph{objects}, they are able to perform actions (\emph{methods}) not readily available to other primitives.  

\subsection{Using Data Types}
In short, \emph{classes} are recipes that create \emph{objects} which do things (with \emph{methods}) and contain \emph{data}. There is perhaps no absolutely perfect way to organize data. However, some approaches to working with data are more useful than others. At the end of the day, programming, and indeed much of what we do in our lives, revolves around the organization and restructuring of data in new and useful ways.\par
\begin{tcolorbox}[enhanced,width=5in,center upper,size=fbox,
    fontupper=\large\bfseries,drop shadow southwest,sharp corners]
\textbf{Java is an \emph{object oriented} programming language - which means that the language is structured to work with data as aspects of \emph{objects}.}
\end{tcolorbox}
Earlier, the example of the empty \mintinline{Java}{Class Person} was given, which was basically an empty recipe with no way of being made and no associated data. In order to do anything meaningful however, we will want to create \emph{objects} that have data and can do things i.e. have \emph{methods}. \footnote{Note: many introductions to Java would include the typical ``Hello World'' example as the first program. However, to build a practiced, conceptual understanding of Java as an \emph{object oriented} language - and to reinforce and better practice \emph{object oriented} thinking - this text is written to emphasize an \emph{objects} first approach. }\par
%add tikz diagram here of student with data types
\subsection{First Worked Example - An \emph{object}-first approach}

In Java, basically everything occurs in relationship to some \emph{Class}. Indeed, every Java program \textbf{must} have a \emph{main class}. 

%\begin{code}
\subsubsection{The \textbf{main} class in Java}
\label{code:main}
\begin{minted}{Java}
  public class GenericProgramName {
    public static void main(String[] args) {
        // The magic starts here.
    }  
  }
\end{minted}

The most important aspects to note (for now) in this example are:
\begin{itemize}
\item the curly braces \emph{\{\}}
\item the actual \emph{main method} i.e.  \mintinline{Java}{ public static void main(String[] args) {}}
\item the actual \emph{class} name for the overarching program i.e. \emph{GenericProgramName}
\end{itemize}

In Java, units of code are enclosed in curly braces \emph{\{\}}. The code between the first ``\emph{\{}'' and last ``\emph{\}}'' belongs together. Of course, this can, and often is, subdivided into further little bits. It may help to think of curly braces \emph{\{\}} as boxes holding code. As with boxes, larger boxes can contain varied combinations of boxes within boxes - so too is true of curly braces cf. \emph{\[\left\{\left\{\left\{\left\{\right\}\left\{\right\}\right\}\right\}\right\}\]} \par

%\[\left\{ 1 +\left\{2+\left\{3+4\left\{\right\}\right\}a\right\}\right\}\] \par

Every Java program needs a \emph{main} method to run. The majority of the program's code may lie outside the \emph{main} method - however, code execution (what is run) begins here. \par
The  \mintinline{Java}{public class} declaration specifies the name of the overarching program \emph{class} - consequently, the name of the file should match this \emph{class declaration}. \par






%\end{code}



\end{flushleft}


\begin{minted}{c}
  int main() {
    printf('hello world'):
    return 0;
  }
\end{minted}
\end{document}
